### 全向轮步兵学习篇
- 此篇学习文档主要涉及步兵-嵌入式方面
- 对于框架的架构需要提示一点：在config.h文件中通过修改宏来确定是使用底盘/云台代码。
#### 发射机构
  发射机构在控制上分为两个部分：开关摩擦轮 + 控制拨盘电机
- 在逻辑上：只有当开启摩擦轮后才允许控制拨盘拨弹
- 摩擦轮控制很简单，速度环控制电机，速度波动在3-5%之前就可以
- 拨盘比较复杂点，按控制方式分为：速度环、角度环。对于速度环：在测试中用于测试不卡弹的最大弹频，在比赛中用于最大利用枪口冷却率实现火力最大化。对于角度环：在比赛中分为单发、五连发，目前在与视觉自瞄进行了配合：采用自动单/多发控制，进而控制发射机构。
- 比赛规则中发射机构具备枪口热量限制，具体规则请查阅官方手册，如果超限的话，电管的booter会自动断电一段时间，严重影响比赛中机器人的性能！因此在控制上我们需要获取实时获取枪口热量（自己算/利用裁判系统回传），并在超限前做出预防措施（停止拨弹/利用冷却降低拨弹速度）。
#### 云台
  云台控制上分为两个部分：pitch轴和yaw轴。
- 在逻辑上，我们采用Imu欧拉角+角速度作为数据源闭环控制pitch轴电机和yaw轴电机。
- 云台控制模式有：normol、minipc(自瞄模式)。在normol模式下，可以采用DR16以及VT13等遥控器控制，在minipc模式下，我们采用视觉发送的坐标点并做弹道解算后得到的yaw轴角度和pitch轴角度作为控制信号。
#### 底盘
底盘在控制上有：小陀螺、随动模式
- 在逻辑上，云台控制板接收遥控数据，做处理后发送云台坐标系下的Vx和Vy，底盘控制板接收后，将其转换到底盘坐标系，转换用到的 Theta角度为yaw轴电机编码器的角度与标定值之前的差值，具体代码请仔细查阅底盘控制的源码。
- 比赛规则中底盘功率具备功率限制，具体规则请查阅官方手册，在比赛中如果底盘超限，电管的chassis会断电，严重影响比赛中机器人的性能！因此在控制上我们需要做理论功率预测，实时计算功率缩放因子，在功率超限时利用缩放因子限制电机功率进而限制整体底盘的功率！
#### 下述为代码中几个重要的模块函数，搞懂这些函数的内部逻辑就可以理解步兵的运行逻辑：
```
/**
 * @brief UART3遥控器回调函数
 *
 * @param Buffer UART1收到的消息
 * @param Length 长度
 */
#ifdef GIMBAL
void DR16_UART3_Callback(uint8_t *Buffer, uint16_t Length)
{

    chariot.DR16.DR16_UART_RxCpltCallback(Buffer);
    // 底盘 云台 发射机构 的控制策略

    chariot.TIM_Control_Callback();
}

void VT13_UART_Callback(uint8_t *Buffer, uint16_t Length)
{
    chariot.VT13.VT13_UART_RxCpltCallback(Buffer);

    // 底盘 云台 发射机构 的控制策略
    if (*(Buffer + 0) == 0xA9 && *(Buffer + 1) == 0x53)
    {
        chariot.TIM_Control_Callback();
    }
}
#endif

/**
 * @brief TIM5任务回调函数
 *
 */
void Task1ms_TIM5_Callback()
{

    init_finished++;
    if (init_finished > 2000 && start_flag == 0)
    {
    //Buzzer.Set_NowTask(BUZZER_DEVICE_OFFLINE_PRIORITY);
    //buzzer_setTask(&buzzer, BUZZER_CALIBRATED_PRIORITY);
        start_flag = 1;
    }
    /************ 判断设备在线状态判断 50ms (所有device:电机，遥控器，裁判系统等) ***************/

    chariot.TIM1msMod50_Alive_PeriodElapsedCallback();
    
    //buzzer_taskScheduler(&buzzer);
    /****************************** 交互层回调函数 1ms *****************************************/
    if (start_flag == 1)
    {
#ifdef GIMBAL
        chariot.FSM_Alive_Control.Reload_TIM_Status_PeriodElapsedCallback();
        chariot.FSM_Alive_Control_VT13.Reload_TIM_Status_PeriodElapsedCallback();
#endif
        chariot.TIM_Calculate_PeriodElapsedCallback();

        /****************************** 驱动层回调函数 1ms *****************************************/
        // 统一打包发送
        TIM_CAN_PeriodElapsedCallback();

        //TIM_UART_PeriodElapsedCallback();

        // 给上位机发数据
        TIM_USB_PeriodElapsedCallback(&MiniPC_USB_Manage_Object);

        static int mod5 = 0;
        mod5++;
        if (mod5 == 10) // 上下板通信 100hz
        {
#ifdef GIMBAL
            // 给下板发送数据
            chariot.CAN_Gimbal_Tx_Chassis_Callback();
            chariot.CAN_Gimbal_Tx_Chassis_Callback_1();
#elif defined(CHASSIS)
            // 底盘给云台发消息
            chariot.CAN_Chassis_Tx_Gimbal_Callback();
            chariot.CAN_Chassis_Tx_Gimbal_Callback_1();
#endif
            mod5 = 0;
        }
    }
}
```